<script>
    changeTitle('JavaScript 6');
</script>

<h2 id="javascript-general">JavaScript in het algemeen</h2>
<article>
    <p>
        JavaScript is een scripttaal die gedefinieerd is in de standaard ECMAScript.
        Sinds 2012 wordt ECMAScript 5.1 ondersteund door alle moderne browsers.
        JavaScript is zowel object-georiënteerd, functioneel als imperatief. JavaScript kan in browsers draaien maar ook
        in andere omgevingen zoals node.js.
        <a href="https://developer.mozilla.org/nl/docs/Web/JavaScript"></a>
    </p>
    <p>
        Binnen een browser heeft JavaScript toegang tot de DOM API. DOM staat voor Document Object Model en bevat een
        set aan objecten waarmee elementen op een HTML pagina gemanipuleerd kunnen worden.
        <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/JavaScript_technologies_overview"
           class="ref"></a>
    </p>
</article>
<h2 id="js-vs-java">JavaScript vs Java</h2>
<article>
    <p>
        JavaScript wordt vaak verward met Java. Echter zijn het twee verschillende programmeertalen. Bijvoorbeeld
        JavaScript gebruikt prototype-gebaseerde overerving en Java gebruikt klassen. Java heeft een streng type model
        waarbij je niet zomaar tussen verschillende types kan casten, JavaScript heeft een dynamisch type model waarbij
        je alles aan een variabele kan toewijzen.
        <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Introduction#JavaScript_and_Java"
           class="ref"></a>
    </p>
</article>
<h2 id="es6">JavaScript 6</h2>
<article>
    <p>
        In 2015 is de 6de versie van JavaScript vastgelegd in de standaard ECMAScript 2015. Deze versie staat ook bekend
        als ECMAScript 6 of ES6.
        <a href="http://www.ecma-international.org/ecma-262/6.0/" class="ref"></a>
        <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla"
           class="ref"></a>
    </p>
</article>
<h3 id="nieuw-es6">Nieuw in JavaScript 6</h3>
<article>
    <p>
        De volgende onderdelen zijn nieuw in JavaScript 6:
        <a href="https://github.com/lukehoban/es6features" class="ref"></a>
    </p>
    <ul>
        <li>Lambda expressies</li>
        <li>Class-based OO zoals in Java of C&num;</li>
        <li>String interpolation</li>
        <li>Destructuring</li>
        <li>Constants</li>
        <li>Block scoped variables</li>
        <li>For Of iterators</li>
        <li>Modules</li>
        <li>Promises</li>
    </ul>
</article>
<h4 id="lambda">Lambda expressies</h4>
<article>
    <p>
        Met behulp van de arrow <code>=></code> notatie ondersteunt JavaScript 6 lambda expressies.
        <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-arrow-function-definitions" class="ref"></a>
    </p>
    <p>
        Op deze manier kan je een lamdbda expressie meegeven aan een functie:
        <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-arrow-function-definitions" class="ref"></a>
        <code class="code-block">
            var numbers = []; // some array
            numbers.forEach(v =&gt; {
            &Tab;console.log(v);
            });
        </code>
        Voor JavaScript 6 zou dat zo moeten:
        <code class="code-block">
            var numbers = []; // some array
            numbers.forEach(function(v) {
            &Tab;console.log(v);
            });
        </code>
    </p>
</article>
<h4 id="classes">Classes</h4>
<article>
    <p>
        Sinds JavaScript 6 is het mogelijk om klassen te definiëren op dezelfde manier als
        in Java of C&num;
        <a href="http://www.sitepoint.com/understanding-ecmascript-6-class-inheritance/" class="ref"></a>
    </p>
    <p>
        Voor heen kon je objecten op de volgende twee manieren aanmaken:

        <br/><br/>
        De JavaScript object notatie:
        <code class="code-block">
            var person = {
            &Tab;name: &#39;Harry&#39;,
            &Tab;age: 20,
            &Tab;sayHello: function() {
            &Tab;&Tab;console.log(&#39;Hello&#39;);
            &Tab;}
            }

            person.sayHello();
        </code>
        <br/>
        De JavaScript constructor functie:
        <code class="code-block">
            var Person = function () {
            &Tab;this.name = &#39;Harry&#39;;
            &Tab;this.age = 20;

            &Tab;this.sayHello = function () {
            &Tab;&Tab;console.log(&#39;Hello&#39;);
            &Tab;}
            }

            new Person().sayHello();
        </code>
        <br/>
        Met JavaScript 6 is het mogelijk om een class te declareren:
        <code class="code-block">
            class Person {
            &Tab; // getter for name
            &Tab;get name() {
            &Tab;&Tab;return this._name;
            &Tab;}

            &Tab; //setter for name
            &Tab;set name(value) {
            &Tab;&Tab;this._name = value;
            &Tab;}

            &Tab;get age() {
            &Tab;&Tab;return this._age;
            &Tab;}

            &Tab;set age(value) {
            &Tab;&Tab;this._age = value;
            &Tab;}

            &Tab; //normal method
            &Tab;sayHello() {
            &Tab;&Tab;console.log(&#39;Hello&#39;);
            &Tab;}
            }

            new Person().sayHello();
        </code>

        Zoal is te zien in het code voorbeeld, is het mogelijk om getters en setters te gebruiken voor properties die
        bij
        een class horen.
    </p>
    <p>
        Dit is vooral syntactic sugar voor de functie constructor notatie.
        Het wordt interessanter als er een voorbeeld genomen wordt voor object inheritance.
        <br/>
        In het volgende voorbeeld is er een stukje JavaScript te zien wat gegeneerd is door TypeScript om inheritance to
        simuleren:
        <code class="code-block">
            var __extends = this.__extends || function (d, b) {
            &Tab;for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            &Tab;function __() { this.constructor = d; }
            &Tab;__.prototype = b.prototype;
            &Tab;d.prototype = new __();
            };
            var SwitchBooleanAction = (function (_super) {
            &Tab;__extends(SwitchBooleanAction, _super);
            &Tab;function SwitchBooleanAction(triggerOptions, target, propertyPath, condition) {
            &Tab;&Tab;_super.call(this, triggerOptions, condition);
            &Tab;&Tab;this.propertyPath = propertyPath;
            &Tab;&Tab;this._target = target;
            }
            &Tab;SwitchBooleanAction.prototype.execute = function () {
            &Tab;&Tab;this._target[this._property] = !this._target[this._property];
            &Tab;};
            &Tab;return SwitchBooleanAction;
            })(BABYLON.Action);
        </code>

        Dit is zeer complex. JavaScript 6 heeft hiervoor het keyword <code>extends</code> geïntroduceerd.
        In het volgende voorbeeld wordt de class person uit het eerdere voorbeeld extended met de class child.
        <code class="code-block">
            class Child extends Person {
            &Tab;eatCandy() {
            &Tab;&Tab;// do something
            &Tab;}
            }

            var child = new Child();
            child.age = 5; // access Person property
            child.eatCandy(); // access new method
        </code>
    </p>
</article>
<h4 id="string-interpolation">String interpolation</h4>
<article>
    In JavaScript kunnen strings concatenated worden met de <code>+</code> operator.
    In sommige programmeertalen kan je values interpoleren in een string literal.
    <a href="https://developers.google.com/web/updates/2015/01/ES6-Template-Strings"
       class="ref"></a>
    Sinds JavaScript 6 is dit ook mogelijk. Dit kan met de volgende notatie:
    <code class="code-block">
        var greeting = 'world';
        console.log('Hello ${world}!');
        // output: Hello world!
    </code>
</article>
<h4 id="destructuring">Destructuring</h4>
<h4 id="const">Constants</h4>
<article>
    <p>
        Voorheen was het alleen mogelijk om waarden op te slaan in variabelen. In JavaScript 6 is de keyword
        <code>const</code> geïntroduceerd<a
            href="http://www.ecma-international.org/ecma-262/6.0/#sec-function-definitions-static-semantics-isconstantdeclaration"
            class="ref"></a> waarmee afgedwongen wordt dat een waarde constant is.
        Dit voorkomt dat waarden die constant zouden moeten zijn per ongeluk overgeschreven worden. Ook nodigt dit uit
        om zogenaamde <em>magic numbers</em> in constants op te slaan.
        <br/>
        Hierbij het volgende voorbeeld:
        <code class="code-block">
            var a = 'this is variable';
            const b = 'this is constant';

            console.log(a);
            console.log(b);

            a = 'new value';
            b = 'new value'; // SyntaxError: unknown; Line 8: "b" is read-only
        </code>
    </p>
</article>
<h4 id="let">Block scoped variables</h4>
<article>
    <p>
        Door een variabele te declareren met de keyword <code>var</code> is de variabele beschikbaar in een zogenaamde
        closure.
        Daarnaast past JavaScript <em>hoisting</em> toe. Dat betekent dat een variabele beschikbaar is binnen de hele
        closure, en het maakt niet uit wanneer die declared is. <a
            href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var#var_hoisting"
            class="ref"></a>
        Dit kan uitgelegd worden met het volgende code voorbeeld:
    </p>
    <p>
        <code class="code-block">
            a = 5;
            // multiple lines of code
            var a;
        </code>
        De JavaScript interpreter zal dit begrijpen als:
        <code class="code-block">
            var a;
            a = 5;
            // multiple lines of code
        </code>
    </p>
    <p>
        Alle <code>var</code> declaraties worden door de compiler bovenaan de interpreter geplaatst. Dit kan vreemde
        situaties <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let"
                     class="ref"></a>
        opleveren zoals te zien is in het volgende code voorbeeld:
        <code class="code-block">
            var x = 1;
            if(true) {
            &Tab;var x = 5;
            }
            console.log(x); // output: 5
        </code>
        Je zou verwachten dat de tweede declaratie van <code>var x</code> gescheiden is van de eerste declaratie. Echter
        verwijzen beide naar dezelfde waarde, dus <code>var x = 5</code> overschrijft de huidige waarde van x.
    </p>
    <p>
        Om dit soort onverwachte resultaten te voorkomen is in JavaScript 6 het keyword <code>let</code> geïntroduceerd.<a
            href="http://www.ecma-international.org/ecma-262/6.0/#sec-function-definitions-static-semantics-isconstantdeclaration"
            class="ref"></a> Met dit keyword kunnen variabelen niet buiten de <em>block scope</em> gebruikt worden
        waarin ze gedeclareerd zijn.<br/>
        Hierbij hetzelfde code voorbeeld maar dan met het <code>let</code> keyword:
        <code class="code-block">
            let x = 1;
            if(true) {
            &Tab;let x = 5;
            }
            console.log(x); // output: 1
        </code>
        De eerste declaratie van <em>x</em> geldt voor de global scope. De tweede declaratie van <em>x</em> geldt voor
        de block scope van het <em>if</em> statement. Dit zorgt ervoor dat <em>x</em> nog steeds de waarde 1 heeft op
        het moment dat <em>console.log</em> wordt aangeroepen.<a
            href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let"
            class="ref"></a>
    </p>
</article>
<h4 id="for-of">For Of iterators</h4>
<h4 id="modules">Modules</h4>
<h4 id="promises">Promises</h4>

