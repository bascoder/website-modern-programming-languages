<article>
    <h2 id="javascript-general">JavaScript in het algemeen</h2>
    <p>
        JavaScript is een scripttaal die gedefinieerd is in de standaard ECMAScript.
        Sinds 2012 wordt ECMAScript 5.1 ondersteund door alle moderne browsers.
        JavaScript is zowel object-georiënteerd, functioneel als imperatief. JavaScript kan in browsers draaien maar ook
        in andere omgevingen zoals node.js.
        <a href="https://developer.mozilla.org/nl/docs/Web/JavaScript"></a>
    </p>
    <p>
        Binnen een browser heeft JavaScript toegang tot de DOM API. DOM staat voor Document Object Model en bevat een
        set aan objecten waarmee elementen op een HTML pagina gemanipuleerd kunnen worden.
        <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/JavaScript_technologies_overview"
           class="ref"></a>
    </p>
    <h3>Populariteit</h3>
    <p>
        De volgende grafiek geeft het aantal toegevoegde repositories op GitHub weer per jaar wat JavaScript gebruikt.
    </p>
    <div id="js-popularity-graph" class="plot-graph"></div>
</article>
<article>
    <h2 id="js-vs-java">JavaScript vs Java</h2>
    <p>
        JavaScript wordt vaak verward met Java. Echter zijn het twee verschillende programmeertalen. Bijvoorbeeld
        JavaScript gebruikt prototype-gebaseerde overerving en Java gebruikt klassen. Java heeft een streng type model
        waarbij je niet zomaar tussen verschillende types kan casten, JavaScript heeft een dynamisch type model waarbij
        je alles aan een variabele kan toewijzen.
        <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Introduction#JavaScript_and_Java"
           class="ref"></a>
    </p>
</article>
<article>
    <h2 id="es6">JavaScript 6</h2>
    <p>
        In 2015 is de 6de versie van JavaScript vastgelegd in de standaard ECMAScript 2015. Deze versie staat ook bekend
        als ECMAScript 6 of ES6.
        <a href="http://www.ecma-international.org/ecma-262/6.0/" class="ref"></a>
        <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla"
           class="ref"></a>
    </p>
</article>
<article>
    <h3 id="nieuw-es6">Nieuw in JavaScript 6</h3>
    <p>
        De volgende onderdelen zijn nieuw in JavaScript 6:
        <a href="https://github.com/lukehoban/es6features" class="ref"></a>
    </p>
    <ul>
        <li>Lambda expressies</li>
        <li>Class-based OO zoals in Java of C&num;</li>
        <li>String interpolation</li>
        <li>Destructuring</li>
        <li>Constants</li>
        <li>Block scoped variables</li>
        <li>For Of iterators</li>
        <li>Modules</li>
        <li>Promises</li>
    </ul>
</article>
<article>
    <h4 id="lambda">Lambda expressies</h4>
    <p>
        Met behulp van de arrow <code>=></code> notatie ondersteunt JavaScript 6 lambda expressies.
        <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-arrow-function-definitions" class="ref"></a>
    </p>
    <p>
        Op deze manier kan je een lamdbda expressie meegeven aan een functie:
        <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-arrow-function-definitions" class="ref"></a>
        <code class="code-block">
            var numbers = []; // some array
            numbers.forEach(v =&gt; {
            &Tab;console.log(v);
            });
        </code>
        Voor JavaScript 6 zou dat zo moeten:
        <code class="code-block">
            var numbers = []; // some array
            numbers.forEach(function(v) {
            &Tab;console.log(v);
            });
        </code>
    </p>
</article>
<article>
    <h4 id="classes">Classes</h4>
    <p>
        Sinds JavaScript 6 is het mogelijk om klassen te definiëren op dezelfde manier als
        in Java of C&num;
        <a href="http://www.sitepoint.com/understanding-ecmascript-6-class-inheritance/" class="ref"></a>
    </p>
    <p>
        Voor heen kon je objecten op de volgende twee manieren aanmaken:

        <br/><br/>
        De JavaScript object notatie:
        <code class="code-block">
            var person = {
            &Tab;name: &#39;Harry&#39;,
            &Tab;age: 20,
            &Tab;sayHello: function() {
            &Tab;&Tab;console.log(&#39;Hello&#39;);
            &Tab;}
            }

            person.sayHello();
        </code>
        <br/>
        De JavaScript constructor functie:
        <code class="code-block">
            var Person = function () {
            &Tab;this.name = &#39;Harry&#39;;
            &Tab;this.age = 20;

            &Tab;this.sayHello = function () {
            &Tab;&Tab;console.log(&#39;Hello&#39;);
            &Tab;}
            }

            new Person().sayHello();
        </code>
        <br/>
        Met JavaScript 6 is het mogelijk om een class te declareren:
        <code class="code-block">
            class Person {
            &Tab; // getter for name
            &Tab;get name() {
            &Tab;&Tab;return this._name;
            &Tab;}

            &Tab; //setter for name
            &Tab;set name(value) {
            &Tab;&Tab;this._name = value;
            &Tab;}

            &Tab;get age() {
            &Tab;&Tab;return this._age;
            &Tab;}

            &Tab;set age(value) {
            &Tab;&Tab;this._age = value;
            &Tab;}

            &Tab; //normal method
            &Tab;sayHello() {
            &Tab;&Tab;console.log(&#39;Hello&#39;);
            &Tab;}
            }

            new Person().sayHello();
        </code>

        Zoal is te zien in het code voorbeeld, is het mogelijk om getters en setters te gebruiken voor properties die
        bij
        een class horen.
    </p>
    <p>
        Dit is vooral syntactic sugar voor de functie constructor notatie.
        Het wordt interessanter als er een voorbeeld genomen wordt voor object inheritance.
        <br/>
        In het volgende voorbeeld is er een stukje JavaScript te zien wat gegeneerd is door TypeScript om inheritance to
        simuleren:
        <code class="code-block">
            var __extends = this.__extends || function (d, b) {
            &Tab;for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            &Tab;function __() { this.constructor = d; }
            &Tab;__.prototype = b.prototype;
            &Tab;d.prototype = new __();
            };
            var SwitchBooleanAction = (function (_super) {
            &Tab;__extends(SwitchBooleanAction, _super);
            &Tab;function SwitchBooleanAction(triggerOptions, target, propertyPath, condition) {
            &Tab;&Tab;_super.call(this, triggerOptions, condition);
            &Tab;&Tab;this.propertyPath = propertyPath;
            &Tab;&Tab;this._target = target;
            }
            &Tab;SwitchBooleanAction.prototype.execute = function () {
            &Tab;&Tab;this._target[this._property] = !this._target[this._property];
            &Tab;};
            &Tab;return SwitchBooleanAction;
            })(BABYLON.Action);
        </code>

        Dit is zeer complex. JavaScript 6 heeft hiervoor het keyword <code>extends</code> geïntroduceerd.
        In het volgende voorbeeld wordt de class person uit het eerdere voorbeeld extended met de class child.
        <code class="code-block">
            class Child extends Person {
            &Tab;eatCandy() {
            &Tab;&Tab;// do something
            &Tab;}
            }

            var child = new Child();
            child.age = 5; // access Person property
            child.eatCandy(); // access new method
        </code>
    </p>
</article>
<article>
    <h4 id="string-interpolation">String interpolation</h4>
    In JavaScript kunnen strings concatenated worden met de <code>+</code> operator.
    In sommige programmeertalen kan je values interpoleren in een string literal.
    <a href="https://developers.google.com/web/updates/2015/01/ES6-Template-Strings"
       class="ref"></a>
    Sinds JavaScript 6 is dit ook mogelijk. Dit kan met de volgende notatie:
    <code class="code-block">
        var greeting = 'world';
        console.log('Hello ${world}!');
        // output: Hello world!
    </code>
</article>
<article>
    <h4 id="const">Constants</h4>
    <p>
        Voorheen was het alleen mogelijk om waarden op te slaan in variabelen. In JavaScript 6 is de keyword
        <code>const</code> geïntroduceerd<a
            href="http://www.ecma-international.org/ecma-262/6.0/#sec-function-definitions-static-semantics-isconstantdeclaration"
            class="ref"></a> waarmee afgedwongen wordt dat een waarde constant is.
        Dit voorkomt dat waarden die constant zouden moeten zijn per ongeluk overgeschreven worden. Ook nodigt dit uit
        om zogenaamde <em>magic numbers</em> in constants op te slaan.
        <br/>
        Hierbij het volgende voorbeeld:
        <code class="code-block">
            var a = 'this is variable';
            const b = 'this is constant';

            console.log(a);
            console.log(b);

            a = 'new value';
            b = 'new value'; // SyntaxError: unknown; Line 8: "b" is read-only
        </code>
    </p>
</article>
<article>
    <h4 id="let">Block scoped variables</h4>
    <p>
        Door een variabele te declareren met de keyword <code>var</code> is de variabele beschikbaar in een zogenaamde
        closure.
        Daarnaast past JavaScript <em>hoisting</em> toe. Dat betekent dat een variabele beschikbaar is binnen de hele
        closure, en het maakt niet uit wanneer die declared is. <a
            href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var#var_hoisting"
            class="ref"></a>
        Dit kan uitgelegd worden met het volgende code voorbeeld:
    </p>
    <p>
        <code class="code-block">
            a = 5;
            // multiple lines of code
            var a;
        </code>
        De JavaScript interpreter zal dit begrijpen als:
        <code class="code-block">
            var a;
            a = 5;
            // multiple lines of code
        </code>
    </p>
    <p>
        Alle <code>var</code> declaraties worden door de compiler bovenaan de interpreter geplaatst. Dit kan vreemde
        situaties <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let"
                     class="ref"></a>
        opleveren zoals te zien is in het volgende code voorbeeld:
        <code class="code-block">
            var x = 1;
            if(true) {
            &Tab;var x = 5;
            }
            console.log(x); // output: 5
        </code>
        Je zou verwachten dat de tweede declaratie van <code>var x</code> gescheiden is van de eerste declaratie. Echter
        verwijzen beide naar dezelfde waarde, dus <code>var x = 5</code> overschrijft de huidige waarde van x.
    </p>
    <p>
        Om dit soort onverwachte resultaten te voorkomen is in JavaScript 6 het keyword <code>let</code> geïntroduceerd.<a
            href="http://www.ecma-international.org/ecma-262/6.0/#sec-function-definitions-static-semantics-isconstantdeclaration"
            class="ref"></a> Met dit keyword kunnen variabelen niet buiten de <em>block scope</em> gebruikt worden
        waarin ze gedeclareerd zijn.<br/>
        Hierbij hetzelfde code voorbeeld maar dan met het <code>let</code> keyword:
        <code class="code-block">
            let x = 1;
            if(true) {
            &Tab;let x = 5;
            }
            console.log(x); // output: 1
        </code>
        De eerste declaratie van <em>x</em> geldt voor de global scope. De tweede declaratie van <em>x</em> geldt voor
        de block scope van het <em>if</em> statement. Dit zorgt ervoor dat <em>x</em> nog steeds de waarde 1 heeft op
        het moment dat <em>console.log</em> wordt aangeroepen.<a
            href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let"
            class="ref"></a>
    </p>
</article>
<article>
    <h4 id="for-of">For Of iterators</h4>
    <p>Sinds JavaScript 6 is het mogelijk om over <em>iterable</em> collections te itereren met een for of loop. Deze is
        vergelijkbaar met <em>foreach</em> in C&num;</p><a
        href="https://developer.mozilla.org/nl/docs/Web/JavaScript/Reference/Statements/for...of" class="ref"></a>

    <code class="code-block">
        var users = [{},{}];
        for(let user of users) {
        &Tab;// do something with user
        }
    </code>
</article>
<article>
    <h4 id="modules">Modules</h4>
    <p>
        In het tijdperk voor JavaScript 6 zijn er allerlei libraries ontwikkeld om het mogelijk te maken om code te
        scheiden in modules. Het voordeel hiervan is dat bepaalde code private gemaakt kan worden en maar
        een deel gebruikt wordt om een API te exposen. Ook voorkomt het dat de global namespace vervuild wordt met
        allerlei globale variabelen. Mochten er twee libraries zijn die allebei het symbool &dollar; in gebruik nemen,
        dan levert dit conflicten op als deze niet in modules zijn weggestopt.
    </p>
    <p>
        Een voorbeeld van zo'n library is <a href="http://requirejs.org/">RequireJS</a>. Deze libraries maakt het
        mogelijk om code in te delen in modules en modules asynchroon in te laden wanneer nodig. Ook kan een alias
        worden gegeven aan een namespace van een module, dit voorkomt dat twee libraries conflicten wanneer zei dezelfde
        namespace gebruiken.<a href="http://requirejs.org/docs/jquery.html" class="ref"></a>
    </p>
    <p>
        Sinds JavaScript 6 worden modules native ondersteund. Met het keyword <code>export</code> kunnen functies
        beschikbaar worden gesteld voor andere modules. Met het keyword <code>import</code> kunnen functies of gehele
        modules geïmporteerd worden.<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-modules"
                                       class="ref"></a><a
            href="https://developer.mozilla.org/nl/docs/Web/JavaScript/Reference/Statements/import" class="ref"></a>
        <br/>
        Dit gaat als volgt:
        <code class="code-block">
            import * as alias from 'module-name';
            alias.aFunction();
            alias.anotherFunction();
        </code>
        In dit voorbeeld worden alle functies uit <em>module-name.js</em> geïmporteerd. Vervolgens kan met de alias elke
        geëxporteerde functie aangeroepen worden.
        Het is niet verplicht om een alias mee te geven, maar dit voorkomt conflicten met andere modules.
    </p>
</article>
<article>
    <h4 id="promises">Promises</h4>
    <p>
        In JavaScript omgevingen zoals de browser of NodeJS is het mogelijk om code asynchroon uit te voeren. Meestal
        wordt een callback functie meegegeven om het resultaat af te vangen wanneer dit beschikbaar is.
        <a href="https://developer.mozilla.org/en-US/docs/AJAX/Getting_Started" class="ref"></a><a
            href="http://sdsu-dspace.calstate.edu/bitstream/handle/10211.3/125396/Vaddineni_sdsu_0220N_10472.pdf?sequence=1"
            class="ref"></a>
        Echter lost elke library asynchrone afhandeling anders op. Sinds JavaScript 6 is een uniforme manier
        geïntroduceerd om asynchrone acties af te handelen inclusief error handling: <em>promises</em>.
        Het promise object heeft de methods <em>then</em> en <em>catch</em>, hier kunnen de callback functies aan mee
        worden gegeven. In de constructor wordt een executor
        functie meegegeven, deze functie kan na een asynchrone actie de <em>resolve</em> of <em>reject</em> functie
        aanroepen. Vervolgens wordt de respectieve callbacks aangeroepen, then voor resolve, en catch voor reject.<a
            href="https://developer.mozilla.org/nl/docs/Web/JavaScript/Reference/Global_Objects/Promise"
            class="ref"></a>
    </p>
</article>
<script src="js/javascript.js"></script>
